name: Issue-PR Enforcement

on:
  pull_request:
    types: [opened, edited]

permissions:
  issues: write
  pull-requests: write
  contents: read

jobs:
  check-issue-link:
    name: 🔗 Check Issue Link
    runs-on: ubuntu-latest
    steps:
      - name: 🐍 Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'

      - name: 📦 Install deps
        run: pip install --no-cache-dir requests

      - name: ✅ Validate and Enforce (inline Python)
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          REPO: ${{ github.repository }}
          PR_NUMBER: ${{ github.event.pull_request.number }}
          PR_TITLE: ${{ github.event.pull_request.title }}
          PR_BODY: ${{ github.event.pull_request.body }}
        run: |
          python - << 'PY'
          import os, re, requests

          token = os.environ['GITHUB_TOKEN']
          repo = os.environ['REPO']
          pr_number = int(os.environ['PR_NUMBER'])
          title = os.environ.get('PR_TITLE') or ''
          body = os.environ.get('PR_BODY') or ''

          headers = {
              'Authorization': f'Bearer {token}',
              'Accept': 'application/vnd.github.v3+json',
              'Content-Type': 'application/json',
          }
          base = f'https://api.github.com/repos/{repo}'

          def add_labels(num, labels):
              r = requests.post(f'{base}/issues/{num}/labels', headers=headers, json=labels, timeout=30)
              r.raise_for_status()

          def remove_label(num, name):
              r = requests.delete(f'{base}/issues/{num}/labels/{name}', headers=headers, timeout=30)
              if r.status_code not in (200, 204, 404):
                  r.raise_for_status()

          def comment(num, msg):
              r = requests.post(f'{base}/issues/{num}/comments', headers=headers, json={'body': msg}, timeout=30)
              r.raise_for_status()

          regex = re.compile(r"\b(?:closes|fixes|resolves)\s+#(\d+)\b", re.IGNORECASE)
          refs = [m.group(1) for m in regex.finditer(body)] + [m.group(1) for m in regex.finditer(title)]
          uniq = sorted(set(refs), key=int)

          def fail(msg):
              add_labels(pr_number, ['needs-issue-link'])
              comment(pr_number, f'❌ {msg}')
              print(msg)
              raise SystemExit(1)

          if len(uniq) == 0:
              fail('Missing Issue Link. Please add exactly one reference using "Closes #XXX".')
          if len(uniq) > 1:
              fail(f'Multiple issues referenced: {", ".join(f"#{n}" for n in uniq)}. Link exactly one issue.')

          issue_no = int(uniq[0])
          # Ensure issue exists and is open
          ir = requests.get(f'{base}/issues/{issue_no}', headers=headers, timeout=30)
          if ir.status_code == 404:
              fail(f'Referenced issue #{issue_no} does not exist.')
          ir.raise_for_status()
          if ir.json().get('state') != 'open':
              fail(f'Referenced issue #{issue_no} is {ir.json().get("state")}. Reference an open issue.')

          # Ensure no other open PR references this issue
          prs = requests.get(f'{base}/pulls?state=open&per_page=100', headers=headers, timeout=30)
          prs.raise_for_status()
          for pr in prs.json():
              if pr.get('number') == pr_number:
                  continue
              other_title = pr.get('title') or ''
              other_body = pr.get('body') or ''
              re_issue = re.compile(rf"\b(?:closes|fixes|resolves)\s+#{issue_no}\b", re.IGNORECASE)
              if re_issue.search(other_title) or re_issue.search(other_body):
                  fail(f'Issue #{issue_no} is already referenced by PR #{pr.get("number")}. Keep a 1:1 mapping.')

          # Success
          remove_label(pr_number, 'needs-issue-link')
          add_labels(pr_number, ['issue-linked', 'ready-for-review'])
          comment(pr_number, f'✅ Issue link verified: #{issue_no}. Ready for review.')
          print('Link check passed')
          PY
